# 代码大纲

## Operand function

- `newOperand(int kind, ...)`: 创建一个新的操作数实例。根据操作数的类型（`kind`），它使用可变参数列表来接收不同类型的值，并将它们保存在相应的字段中。操作数的类型包括常数（`OP_CONSTANT`）、变量（`OP_VARIABLE`）、地址（`OP_ADDRESS`）、标签（`OP_LABEL`）、函数（`OP_FUNCTION`）和关系运算符（`OP_RELOP`）。

- `setOperand(pOperand p, int kind, void* val)`: 设置操作数的类型和值。根据给定的类型和值，它更新操作数的字段。如果操作数之前包含有字符串值，则释放内存并更新为新的字符串值。

- `deleteOperand(pOperand p)`: 释放一个操作数实例占用的内存。根据操作数的类型，它释放相应字段中存储的字符串值的内存。

- `printOp(FILE* fp, pOperand op)`: 打印操作数的值。根据操作数的类型，它在标准输出或给定的文件中打印相应的值。

## InterCode function

- `newInterCode(int kind, ...)`: 创建一个新的中间代码（`InterCode`）实例。根据不同的代码类型（`kind`），它使用可变参数列表来接收不同数量的操作数，并将它们保存在相应的字段中。

- `deleteInterCode(pInterCode p)`: 释放一个中间代码实例占用的内存。根据代码类型，它释放相应字段中存储的操作数的内存。

- `printInterCode(FILE* fp, pInterCodeList interCodeList)`: 将中间代码列表（`InterCodeList`）打印到文件或标准输出。根据不同的代码类型，它以特定的格式打印每个中间代码。

- `newInterCodes(pInterCode code)`: 创建一个新的中间代码节点（`InterCodes`）实例，并将给定的中间代码存储在节点中。

- `deleteInterCodes(pInterCodes p)`: 释放一个中间代码节点实例占用的内存。

- `newArg(pOperand op)`: 创建一个新的参数节点（`Arg`）实例，并将给定的操作数存储在节点中。

- `newArgList()`: 创建一个新的参数列表（`ArgList`）实例。

- `deleteArg(pArg p)`: 释放一个参数节点实例占用的内存。

- `deleteArgList(pArgList p)`: 释放一个参数列表实例占用的内存。

- `addArg(pArgList argList, pArg arg)`: 将一个参数节点添加到参数列表中。

## InterCodeList function

1. `newInterCodeList()`: 这个函数初始化一个新的中间代码列表（`InterCodeList`）实例。它为列表结构分配内存，初始化其成员（`head`、`cur`、`tempVarNum`、`labelNum`），然后返回指向它的指针。

2. `deleteInterCodeList()`: 这个函数释放一个中间代码列表所占用的内存。它接受一个指向 `InterCodeList` 的指针作为输入，释放列表中每个 `InterCodes` 节点占用的内存，最后释放列表本身占用的内存。

3. `addInterCode()`: 这个函数将一个新的中间代码（`InterCodes`）添加到中间代码列表（`InterCodeList`）的末尾。它接受一个指向中间代码列表（`interCodeList`）和一个指向新中间代码（`newCode`）的指针作为输入。如果列表为空，它将 `head` 和 `cur` 指针都设置为新代码。否则，它将新代码追加到列表的末尾，并更新 `cur` 指针。

4. `newTemp()`: 这个函数为中间代码生成生成一个新的临时变量操作数（`pOperand`）。它根据 `tempVarNum` 的当前值创建一个唯一的临时变量名（例如 "t1"、"t2" 等），递增 `tempVarNum`，创建一个新的操作数，类型为 `OP_VARIABLE`，名称为生成的名称，并返回指向它的指针。

5. `newLabel()`: 类似于 `newTemp()`，这个函数为中间代码生成生成一个新的标签操作数（`pOperand`）。它根据 `labelNum` 的当前值创建一个唯一的标签名（例如 "label1"、"label2" 等），递增 `labelNum`，创建一个新的操作数，类型为 `OP_LABEL`，名称为生成的名称，并返回指向它的指针。

6. `getSize()`: 这个函数计算给定类型（`pType`）的大小（以字节为单位）。它支持基本类型（4 字节）、数组（数组大小 * 数组元素大小）和结构体。对于结构体，它设置了一个错误标志（`interError`）并打印了一个消息，表明代码中包含结构体类型的变量或参数。这表明编译器当前在其中间表示中不支持结构体。

7. `genInterCodes` 函数：这是一个递归函数，它接受一个指向节点的指针作为参数。它首先检查节点是否为空，如果为空则直接返回。然后它检查节点的名称是否为 "ExtDefList"，如果是，则调用 `translateExtDefList` 函数；否则，递归地调用 `genInterCodes` 函数来处理当前节点的子节点和兄弟节点。

8. `genInterCode` 函数：这是一个可变参数函数，根据传入的指令类型生成相应的中间代码。它接受一个整数参数 `kind`，表示生成的中间代码的类型。根据 `kind` 的值，它使用 `switch` 语句执行不同的操作：

   - 对于某些类型的中间代码（如标签、函数、跳转、返回等），它从可变参数列表中提取一个操作数，并生成相应的中间代码。如果操作数的类型是地址，则需要生成额外的中间代码来处理。
   
   - 对于赋值、取地址、函数调用等操作，它从可变参数列表中提取两个操作数，并根据需要生成额外的中间代码。
   
   - 对于算术运算和逻辑运算，它从可变参数列表中提取三个操作数，并根据需要生成额外的中间代码来处理地址操作数。
   
   - 对于声明操作，它从可变参数列表中提取一个操作数和一个大小，并生成相应的中间代码。
   
   - 对于条件跳转操作，它从可变参数列表中提取四个操作数，并生成相应的中间代码。

## translate function

1. `translateExtDefList` 函数：用于处理全局定义列表。它遍历所有的全局定义，并调用相应的函数进行处理。在这里，它只处理函数定义，因为对于全局变量和类型定义，暂时没有生成中间代码的需要。

2. `translateFunDec` 函数：处理函数定义。它生成函数的声明中间代码，包括定义函数名和函数参数列表中的参数。

3. `translateCompSt` 函数：处理函数体。它生成函数体中的变量声明和语句的中间代码。

4. `translateDefList` 函数和 `translateDef` 函数：处理变量定义。它们生成变量定义语句的中间代码，包括变量声明和初始化。

5. `translateStmtList` 函数和 `translateStmt` 函数：处理语句列表。它们生成语句列表中每个语句的中间代码，包括表达式、复合语句、返回语句、条件语句和循环语句等。

6. `translateDecList` 函数和 `translateDec` 函数：处理变量声明列表。它们生成变量声明的中间代码，包括变量名和数组大小。

7. `translateVarDec` 函数：处理变量声明。它生成变量声明的中间代码，包括基本类型变量和一维数组变量。

8. `translateExp` 函数：处理表达式。它生成表达式的中间代码，包括赋值、算术运算、逻辑运算、函数调用等。

9. `translateExp` 函数：该函数用于将表达式转换为中间代码。它通过递归处理不同类型的表达式，包括赋值、算术运算、逻辑运算、函数调用、数组访问、结构体访问等。具体的处理逻辑如下：
    - 对于复合表达式，如 `AND`、`OR`、`RELOP`、`NOT`，会生成相应的中间代码，并根据表达式结果跳转到标签。
    - 对于算术运算，如 `PLUS`、`MINUS`、`STAR`、`DIV`，会生成相应的中间代码，进行相应的计算。
    - 对于数组访问和结构体访问，会根据假设处理，生成相应的中间代码，如计算地址等。
    - 对于函数调用，会根据参数是否为空来判断是有参调用还是无参调用，并生成相应的中间代码。

10. `translateCond` 函数：该函数用于将条件表达式转换为中间代码。它主要处理逻辑运算和关系运算，根据结果生成相应的跳转指令。具体处理逻辑包括：
    - 处理逻辑运算，如 `AND`、`OR`，会根据短路规则生成相应的跳转指令。
    - 处理关系运算，如 `<`、`>`、`==` 等，会生成相应的中间代码，根据结果进行跳转。

11. `translateArgs` 函数：该函数用于处理函数调用时的参数列表。它会递归处理参数列表中的每个参数，并将参数转换为中间代码表示形式，然后添加到参数列表中。